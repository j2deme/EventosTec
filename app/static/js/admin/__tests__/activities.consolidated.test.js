// Consolidated tests for activities feature (combined from several smaller files)
// This file is generated by the test consolidation step to reduce test file proliferation
require("../../app.js");
const activitiesManager = require("../activities.js");

describe("activitiesManager (consolidated)", () => {
  describe("unit and helper methods", () => {
    let mgr;
    beforeEach(() => {
      global.showToast = jest.fn();
      mgr = activitiesManager();
    });

    test("updateCalculatedDuration computes hours when valid dates", () => {
      mgr.currentActivity.start_datetime = "2025-09-01T10:00:00Z";
      mgr.currentActivity.end_datetime = "2025-09-01T12:30:00Z";
      mgr.updateCalculatedDuration();
      expect(mgr.calculatedDuration).toBeCloseTo(2.5);
    });

    test("updateCalculatedDuration sets 0 when invalid", () => {
      mgr.currentActivity.start_datetime = "";
      mgr.currentActivity.end_datetime = "";
      mgr.updateCalculatedDuration();
      expect(mgr.calculatedDuration).toBe(0);

      mgr.currentActivity.start_datetime = "2025-09-02T10:00:00Z";
      mgr.currentActivity.end_datetime = "2025-09-01T09:00:00Z";
      mgr.updateCalculatedDuration();
      expect(mgr.calculatedDuration).toBe(0);
    });

    test("updateDateLimits sets minDate/maxDate when event selected", () => {
      mgr.events = [
        {
          id: 1,
          start_date: "2025-09-01T00:00:00Z",
          end_date: "2025-09-02T00:00:00Z",
        },
      ];
      mgr.currentActivity.event_id = 1;
      mgr.updateDateLimits();
      expect(mgr.minDate).toMatch(/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}/);
      expect(mgr.maxDate).toMatch(/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}/);
    });

    test("validateActivityDates returns errors for various invalid scenarios", () => {
      mgr.events = [
        {
          id: 1,
          start_date: "2025-09-05T00:00:00Z",
          end_date: "2025-09-10T00:00:00Z",
        },
      ];

      // No event selected
      let res = mgr.validateActivityDates({
        event_id: 99,
        start_datetime: "",
        end_datetime: "",
      });
      expect(res).toMatch(/Por favor seleccione un evento v/);

      // Start before event start
      res = mgr.validateActivityDates({
        event_id: 1,
        start_datetime: "2025-09-01T00:00:00Z",
        end_datetime: "2025-09-06T00:00:00Z",
      });
      expect(res).toMatch(/no puede ser anterior/);

      // End after event end
      res = mgr.validateActivityDates({
        event_id: 1,
        start_datetime: "2025-09-06T00:00:00Z",
        end_datetime: "2025-09-20T00:00:00Z",
      });
      expect(res).toMatch(/no puede ser posterior/);

      // Start >= End
      res = mgr.validateActivityDates({
        event_id: 1,
        start_datetime: "2025-09-07T00:00:00Z",
        end_datetime: "2025-09-07T00:00:00Z",
      });
      expect(res).toMatch(/La fecha de inicio debe ser anterior/);

      // Valid
      res = mgr.validateActivityDates({
        event_id: 1,
        start_datetime: "2025-09-06T00:00:00Z",
        end_datetime: "2025-09-07T00:00:00Z",
      });
      expect(res).toBeNull();
    });

    test("getAvailableActivities filters out linked activities", () => {
      mgr.currentActivity.event_id = 2;
      mgr.activityRelations = [
        { id: 1, event_id: 2, related_activities: [{ id: 3 }], linked_by: [] },
        { id: 2, event_id: 2, related_activities: [], linked_by: [] },
        { id: 3, event_id: 2, related_activities: [], linked_by: [{ id: 1 }] },
        { id: 4, event_id: 999, related_activities: [], linked_by: [] },
      ];

      const avail = mgr.getAvailableActivities();
      expect(avail.some((a) => a.id === 2)).toBe(true);
      expect(avail.some((a) => a.id === 1)).toBe(false);
      expect(avail.some((a) => a.id === 3)).toBe(false);
    });
  });

  describe("http, fetch and error branches", () => {
    let origFetch, origLocalStorage, origShowToast;
    beforeAll(() => {
      origFetch = global.fetch;
      origLocalStorage = global.localStorage;
      origShowToast = global.showToast;
      global.localStorage = {
        store: {},
        getItem(k) {
          return this.store[k] || null;
        },
        setItem(k, v) {
          this.store[k] = String(v);
        },
        removeItem(k) {
          delete this.store[k];
        },
      };
      global.showToast = jest.fn();
    });
    afterAll(() => {
      global.fetch = origFetch;
      global.localStorage = origLocalStorage;
      global.showToast = origShowToast;
    });

    test("loadActivities throws/sets error when token missing", async () => {
      const comp = activitiesManager();
      global.localStorage.removeItem &&
        global.localStorage.removeItem("authToken");
      global.fetch = jest.fn(() => Promise.resolve({ ok: false }));
      await comp.loadActivities();
      expect(comp.errorMessage).toBeTruthy();
    });

    test("loadActivities handles non-ok response and shows toast", async () => {
      const comp = activitiesManager();
      global.localStorage.setItem("authToken", "tok");
      global.fetch = jest.fn(() =>
        Promise.resolve({ ok: false, status: 500, statusText: "Server Error" })
      );
      await comp.loadActivities();
      expect(comp.errorMessage).toMatch(/Error al cargar actividades/);
      expect(global.showToast).toHaveBeenCalledWith(
        "Error al cargar actividades",
        "error"
      );
    });

    test("loadEvents fills events and loadActivityRelations error is thrown", async () => {
      const comp = activitiesManager();
      global.localStorage.setItem("authToken", "tok");
      global.fetch = jest.fn((url) => {
        if (url === "/api/events/")
          return Promise.resolve({
            ok: true,
            json: () => Promise.resolve([{ id: 1, name: "E" }]),
          });
        if (url === "/api/activities/relations")
          return Promise.resolve({ ok: false });
        return Promise.resolve({
          ok: true,
          json: () =>
            Promise.resolve({
              activities: [],
              current_page: 1,
              pages: 1,
              total: 0,
            }),
        });
      });

      await comp.loadEvents();
      expect(comp.events.length).toBeGreaterThan(0);

      global.fetch = jest.fn(() => Promise.resolve({ ok: false }));
      await expect(comp.loadActivityRelations()).rejects.toThrow();
    });

    test("createActivity handles validation error", async () => {
      const comp = activitiesManager();
      global.localStorage.setItem("authToken", "tok");
      comp.events = [];
      comp.currentActivity = {
        event_id: 999,
        start_datetime: "2025-09-01T10:00",
        end_datetime: "2025-09-01T12:00",
      };
      global.fetch = jest.fn();
      await comp.createActivity();
      expect(comp.errorMessage).toBeTruthy();
    });
  });

  describe("fetch interactions and CRUD flows", () => {
    let origFetch;
    let origLs;
    beforeEach(() => {
      origFetch = global.fetch;
      global.fetch = jest.fn();
      origLs = global.localStorage;
      global.localStorage = {
        _store: {},
        getItem(key) {
          return this._store[key] || null;
        },
        setItem(key, val) {
          this._store[key] = String(val);
        },
      };
      global.showToast = jest.fn();
    });
    afterEach(() => {
      global.fetch = origFetch;
      global.localStorage = origLs;
      delete global.showToast;
      jest.restoreAllMocks();
    });

    test("loadEvents fetches events and stores them", async () => {
      const comp = activitiesManager();
      global.localStorage.setItem("authToken", "token123");
      global.fetch.mockResolvedValueOnce({
        ok: true,
        json: async () => [{ id: 1, name: "E1" }],
      });
      await comp.loadEvents();
      expect(global.fetch).toHaveBeenCalledWith(
        "/api/events/",
        expect.any(Object)
      );
      expect(comp.events.length).toBeGreaterThan(0);
    });

    test("loadActivities fetches paginated activities and sets pagination", async () => {
      const comp = activitiesManager();
      global.localStorage.setItem("authToken", "tok");
      global.fetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          activities: [
            {
              id: 11,
              start_datetime: "2025-09-14T08:00:00Z",
              end_datetime: "2025-09-14T10:00:00Z",
            },
          ],
          current_page: 1,
          pages: 1,
          total: 1,
        }),
      });
      await comp.loadActivities(1);
      expect(global.fetch).toHaveBeenCalled();
      expect(comp.activities[0].id).toBe(11);
      expect(comp.pagination.total).toBe(1);
    });

    test("createActivity posts data and triggers activity-created event on success", async () => {
      const comp = activitiesManager();
      global.localStorage.setItem("authToken", "tok");
      comp.currentActivity = {
        id: null,
        event_id: 2,
        department: "D",
        name: "N",
        description: "desc",
        start_datetime: "2025-09-14T09:00:00",
        end_datetime: "2025-09-14T11:00:00",
        duration_hours: 2,
        activity_type: "type",
        location: "loc",
        modality: "in-person",
        requirements: "",
        max_capacity: 10,
      };
      comp.events = [
        {
          id: 2,
          start_date: "2025-09-10T00:00:00",
          end_date: "2025-09-20T23:59:59",
        },
      ];
      global.fetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({ id: 99 }),
      });
      const spy = jest.spyOn(global.window, "dispatchEvent");
      await comp.createActivity();
      expect(global.fetch).toHaveBeenCalledWith(
        "/api/activities/",
        expect.objectContaining({ method: "POST" })
      );
      expect(spy).toHaveBeenCalledWith(
        expect.objectContaining({ type: "activity-created" })
      );
      spy.mockRestore();
    });

    test("updateActivity PUTs to endpoint and dispatches activity-updated", async () => {
      const comp = activitiesManager();
      global.localStorage.setItem("authToken", "tok");
      comp.currentActivity = {
        id: 55,
        event_id: 2,
        department: "D",
        name: "X",
        start_datetime: "2025-09-14T09:00:00",
        end_datetime: "2025-09-14T10:00:00",
        duration_hours: 1,
        activity_type: "t",
        location: "loc",
        modality: "m",
        requirements: "",
        max_capacity: 10,
      };
      comp.events = [
        {
          id: 2,
          start_date: "2025-09-10T00:00:00",
          end_date: "2025-09-20T23:59:59",
        },
      ];
      global.fetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({ id: 55 }),
      });
      const spy = jest.spyOn(global.window, "dispatchEvent");
      await comp.updateActivity();
      expect(global.fetch).toHaveBeenCalledWith(
        "/api/activities/55",
        expect.objectContaining({ method: "PUT" })
      );
      expect(spy).toHaveBeenCalledWith(
        expect.objectContaining({ type: "activity-updated" })
      );
      spy.mockRestore();
    });

    test("deleteActivity sends DELETE and dispatches activity-deleted", async () => {
      const comp = activitiesManager();
      global.localStorage.setItem("authToken", "tok");
      comp.activityToDelete = { id: 99 };
      global.fetch.mockResolvedValueOnce({ ok: true, json: async () => ({}) });
      const spy = jest.spyOn(global.window, "dispatchEvent");
      await comp.deleteActivity();
      expect(global.fetch).toHaveBeenCalledWith(
        "/api/activities/99",
        expect.objectContaining({ method: "DELETE" })
      );
      expect(spy).toHaveBeenCalledWith(
        expect.objectContaining({ type: "activity-deleted" })
      );
      spy.mockRestore();
    });
  });
});
